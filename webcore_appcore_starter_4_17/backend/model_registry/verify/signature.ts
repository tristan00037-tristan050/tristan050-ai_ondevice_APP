/**
 * Signature Verification Helper
 * Validates signed requests according to SVR03_SIGNING_CANONICAL_PAYLOAD_V1.md
 * Fail-closed: missing/invalid signature => deny with reason_code
 * 
 * Hard rule: ts_ms must come from the signed payload, not regenerated by verifier.
 */

import * as crypto from 'crypto';
import { verify } from '../services/signing';
import { canonicalizeJson } from '../../../../packages/common/src/canon/jcs';
import { canVerifyWithKey, getKey } from '../services/key_store';
import { enforceAntiRollbackFreeze } from "./update_anti_rollback_freeze";
import { getRegistryStore } from '../store';

export type SignatureValidationResult =
  | { valid: true }
  | { valid: false; reason_code: string; status: number };

/**
 * Create canonical JSON payload (v1)
 * Uses shared canonicalization library to ensure server/tests/SDK use same implementation.
 * ts_ms must be provided from the signed payload, not regenerated.
 */
function createCanonicalPayload(
  op: string,
  tenantId: string,
  ts_ms: number,
  body: Record<string, unknown>
): string {
  const payload = {
    v: 'v1',
    ts_ms,
    tenant_id: tenantId,
    op,
    body,
  };
  return canonicalizeJson(payload);
}

/**
 * Get signing key by key_id from key store
 * Checks key state (active/grace/revoked) before returning
 */
function getSigningKey(keyId: string, now_ms: number): { publicKey: string } | null {
  // Check if key can be used for verification (active/grace/revoked check)
  const keyCheck = canVerifyWithKey(keyId, now_ms);
  if (!keyCheck.ok) {
    return null; // Will return KEY_UNKNOWN or KEY_REVOKED or KEY_GRACE_EXPIRED
  }

  // Get key record from store
  const rec = getKey(keyId);
  if (!rec) {
    return null;
  }

  // Return public key (key_store uses PEM format, convert to base64 for verify function)
  // Note: verify function expects base64-encoded PEM
  return {
    publicKey: rec.public_key_pem, // Already base64-encoded PEM from key_store
  };
}

/**
 * Verify signature for artifact register request
 * ts_ms must come from the signed payload, not regenerated.
 */
export function verifyArtifactRegisterSignature(
  tenantId: string,
  body: {
    model_id: string;
    version_id: string;
    platform: string;
    runtime: string;
    sha256: string;
    size_bytes: number;
    storage_ref: string;
  },
  signature?: string,
  sig_alg?: string,
  key_id?: string,
  ts_ms?: number
): SignatureValidationResult {
  // Fail-closed: signature required
  if (!signature) {
    return {
      valid: false,
      reason_code: 'SIGNATURE_MISSING',
      status: 400,
    };
  }

  if (!sig_alg || !key_id) {
    return {
      valid: false,
      reason_code: 'SIGNATURE_MISSING',
      status: 400,
    };
  }

  // Fail-closed: ts_ms must be provided from signed payload
  if (ts_ms === undefined || ts_ms === null) {
    return {
      valid: false,
      reason_code: 'CANONICAL_PAYLOAD_INVALID',
      status: 400,
    };
  }

  // Check key state and get signing key from key store
  const now_ms = Date.now();
  const keyCheck = canVerifyWithKey(key_id, now_ms);
  if (!keyCheck.ok) {
    return {
      valid: false,
      reason_code: keyCheck.reason_code || 'KEY_ID_UNKNOWN',
      status: keyCheck.reason_code === 'KEY_REVOKED' || keyCheck.reason_code === 'KEY_GRACE_EXPIRED' ? 403 : 400,
    };
  }

  const rec = getKey(key_id);
  if (!rec) {
    return {
      valid: false,
      reason_code: 'KEY_ID_UNKNOWN',
      status: 400,
    };
  }

  // Get signing key (convert PEM to base64 for verify function)
  const key = {
    publicKey: rec.public_key_pem, // key_store stores base64-encoded PEM
  };

  // Create canonical payload using ts_ms from signed payload
  const canonicalPayload = createCanonicalPayload('ARTIFACT_REGISTER', tenantId, ts_ms, {
    model_id: body.model_id,
    version_id: body.version_id,
    platform: body.platform,
    runtime: body.runtime,
    sha256: body.sha256,
    size_bytes: body.size_bytes,
    storage_ref: body.storage_ref,
  });

  // Verify signature
  const isValid = verify(
    Buffer.from(canonicalPayload, 'utf-8'),
    signature,
    key.publicKey
  );

  if (!isValid) {
    return {
      valid: false,
      reason_code: 'SIGNATURE_INVALID',
      status: 403,
    };
  }

  return { valid: true };
}

/**
 * Verify signature for delivery apply request
 */
export function verifyDeliveryApplySignature(
  tenantId: string,
  body: {
    model_id: string;
    version_id: string;
    artifact_id: string;
    target: {
      device_class: string;
      min_app_version: string;
    };
  },
  signature?: string,
  sig_alg?: string,
  key_id?: string,
  ts_ms?: number
): SignatureValidationResult {
  // Fail-closed: signature required
  if (!signature) {
    return {
      valid: false,
      reason_code: 'SIGNATURE_MISSING',
      status: 400,
    };
  }

  if (!sig_alg || !key_id) {
    return {
      valid: false,
      reason_code: 'SIGNATURE_MISSING',
      status: 400,
    };
  }

  // Fail-closed: ts_ms must be provided from signed payload
  if (ts_ms === undefined || ts_ms === null) {
    return {
      valid: false,
      reason_code: 'CANONICAL_PAYLOAD_INVALID',
      status: 400,
    };
  }

  // Check key state and get signing key from key store
  const now_ms = Date.now();
  const keyCheck = canVerifyWithKey(key_id, now_ms);
  if (!keyCheck.ok) {
    return {
      valid: false,
      reason_code: keyCheck.reason_code || 'KEY_ID_UNKNOWN',
      status: keyCheck.reason_code === 'KEY_REVOKED' || keyCheck.reason_code === 'KEY_GRACE_EXPIRED' ? 403 : 400,
    };
  }

  const rec = getKey(key_id);
  if (!rec) {
    return {
      valid: false,
      reason_code: 'KEY_ID_UNKNOWN',
      status: 400,
    };
  }

  // Get signing key (convert PEM to base64 for verify function)
  const key = {
    publicKey: rec.public_key_pem, // key_store stores base64-encoded PEM
  };

  // Create canonical payload
  const canonicalPayload = createCanonicalPayload('DELIVERY_APPLY', tenantId, ts_ms, {
    model_id: body.model_id,
    version_id: body.version_id,
    artifact_id: body.artifact_id,
    target: body.target,
  });

  // Verify signature
  const isValid = verify(
    Buffer.from(canonicalPayload, 'utf-8'),
    signature,
    key.publicKey
  );

  if (!isValid) {
    return {
      valid: false,
      reason_code: 'SIGNATURE_INVALID',
      status: 403,
    };
  }

  // P2-2: anti-rollback / anti-freeze (fail-closed)
  // UPDATE-02: use store-based max_seen_version instead of payload default
  // Note: This validation is done here, but actual state update happens in delivery.ts after all checks pass
  try {
    const deliveryPayload = body as any;
    // Extract version number from ModelVersion or version_id
    const store = getRegistryStore();
    const modelVersion = store.getModelVersion(body.version_id);
    const versionStr = modelVersion?.version || body.version_id;
    const versionMatch = String(versionStr).match(/\d+/);
    const incomingVersion = versionMatch ? Number(versionMatch[0]) : Number(versionStr) || 0;
    
    // Get max_seen_version from store (read-only check here, actual update happens in delivery.ts)
    const updateKey = `${tenantId}:${body.model_id}`;
    const updateState = store.getUpdateState(updateKey);
    const maxSeenVersion = updateState?.max_seen_version ?? 0;
    
    const expiresAtMs = Number(deliveryPayload?.expires_at_ms ?? deliveryPayload?.meta?.expires_at_ms ?? Date.now() + 3600000);
    enforceAntiRollbackFreeze({ incomingVersion, maxSeenVersion, expiresAtMs, nowMs: Date.now() });
  } catch (err: any) {
    // Fail-closed: anti-rollback/freeze violations must be rejected
    return {
      valid: false,
      reason_code: err.message?.includes('ANTI_ROLLBACK') ? 'ANTI_ROLLBACK_VIOLATION' : err.message?.includes('ANTI_FREEZE') ? 'ANTI_FREEZE_VIOLATION' : 'UPDATE_CONTRACT_VIOLATION',
      status: 403,
    };
  }

  return { valid: true };
}

/**
 * Verify signature for delivery rollback request
 */
export function verifyDeliveryRollbackSignature(
  tenantId: string,
  body: {
    model_id: string;
    version_id: string;
    artifact_id: string;
    reason_code: string;
  },
  signature?: string,
  sig_alg?: string,
  key_id?: string,
  ts_ms?: number
): SignatureValidationResult {
  // Fail-closed: signature required
  if (!signature) {
    return {
      valid: false,
      reason_code: 'SIGNATURE_MISSING',
      status: 400,
    };
  }

  if (!sig_alg || !key_id) {
    return {
      valid: false,
      reason_code: 'SIGNATURE_MISSING',
      status: 400,
    };
  }

  // Fail-closed: ts_ms must be provided from signed payload
  if (ts_ms === undefined || ts_ms === null) {
    return {
      valid: false,
      reason_code: 'CANONICAL_PAYLOAD_INVALID',
      status: 400,
    };
  }

  // Check key state and get signing key from key store
  const now_ms = Date.now();
  const keyCheck = canVerifyWithKey(key_id, now_ms);
  if (!keyCheck.ok) {
    return {
      valid: false,
      reason_code: keyCheck.reason_code || 'KEY_ID_UNKNOWN',
      status: keyCheck.reason_code === 'KEY_REVOKED' || keyCheck.reason_code === 'KEY_GRACE_EXPIRED' ? 403 : 400,
    };
  }

  const rec = getKey(key_id);
  if (!rec) {
    return {
      valid: false,
      reason_code: 'KEY_ID_UNKNOWN',
      status: 400,
    };
  }

  // Get signing key (convert PEM to base64 for verify function)
  const key = {
    publicKey: rec.public_key_pem, // key_store stores base64-encoded PEM
  };

  // Create canonical payload
  const canonicalPayload = createCanonicalPayload('DELIVERY_ROLLBACK', tenantId, ts_ms, {
    model_id: body.model_id,
    version_id: body.version_id,
    artifact_id: body.artifact_id,
    reason_code: body.reason_code,
  });

  // Verify signature
  const isValid = verify(
    Buffer.from(canonicalPayload, 'utf-8'),
    signature,
    key.publicKey
  );

  if (!isValid) {
    return {
      valid: false,
      reason_code: 'SIGNATURE_INVALID',
      status: 403,
    };
  }

  return { valid: true };
}

